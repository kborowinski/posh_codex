name: Build and Publish Module
on:
  push: # Only trigger the workflow if there is a push
    branches: [
        main, # This will build as well as release (Ideally this should only happen when a PR from develop branch is merged.)
        develop, # This will only build but not release - see the if condition insid the "release" job below.
      ]

  workflow_dispatch: #Enables the possibility to trigger the workflow manually from GitHub Actions in the repository
jobs:
  # Configure skip-duplicate actions
  pre_job:
    # continue-on-error: true # Uncomment once integration is finished
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      should_skip: ${{ steps.skip_check.outputs.should_skip }}
    steps:
      - id: skip_check
        uses: fkirc/skip-duplicate-actions@master
        with:
          # All of these options are optional, so you can remove them if you are happy with the defaults
          concurrent_skipping: "always"
          skip_after_successful_duplicate: "true"
          paths_ignore: '["**.md", ".gitignore", ".prettierrc", "**/Docs/**"]'
          do_not_skip: '["workflow_dispatch", "schedule"]'

  # 1st Job -- Building the module, skip job if should_skip is true
  build:
    needs: pre_job
    if: ${{ needs.pre_job.outputs.should_skip != 'true' }}
    runs-on: ubuntu-latest
    steps:
      # Checkout the main branch
      - uses: actions/checkout@main

        # Setting up required powershell modules
      - name: Set required PowerShell modules
        id: psmodulecache
        uses: potatoqualitee/psmodulecache@v1
        with:
          modules-to-cache: Pester, PSScriptAnalyzer, InvokeBuild, platyPS, PSWriteColor, PSReadLine

        # Setting up the powershell module cache
      - name: Setup PowerShell module cache
        id: cacher
        uses: actions/cache@v2
        with:
          path: ${{ steps.psmodulecache.outputs.modulepath }}
          key: ${{ steps.psmodulecache.outputs.keygen }}

        # Installing the required powershell module, if not cached
      - name: Install required PowerShell modules
        if: steps.cacher.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module ${{ steps.psmodulecache.outputs.needed }} -ErrorAction Stop

        # Running a powershell command to save the module name as an Environment Variable
      - name: Set Module Name
        run: |
          Write-Host $Env:GITHUB_REF
          $ModuleName="PoshCodex"
          echo "MODULE_NAME=$ModuleName" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append
        shell: pwsh

        # Running the InvokeBuild Module Invoke-Build command with "Release configuration"
        # WITH BUMP VERSION, FOR BOTH BRANCHES.
        # Version is bumped regardless of branch, but publish to gallery will only happen if the commit reaches the main branch.
        # And if it does reach the main branch, it means builds have passed anyway.
        # So this workflow should be fine.
      - name: Invoke Build
        shell: pwsh
        run: |
          pwsh -command "Invoke-Build -File ./${{ env.MODULE_NAME }}/build.ps1 -Configuration 'Release' -BumpVersion -Verbose"
          $moduleversion=(Test-ModuleManifest -Path ".\${{ env.MODULE_NAME }}\Source\${{ env.MODULE_NAME }}.psd1").Version.toString()
          echo "Setting Module version environment variable: $moduleversion"
          echo "MODULE_VERSION=$moduleversion" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf-8 -Append

        # Pushing the changes from InvokeBuild to the main branch
      - name: Push changes to Git Repository
        run: |
          git config --global user.name 'rishi255'
          git config --global user.email 'rishikeshrachchh@gmail.com'
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
          git add .
          echo "Getting module number from GitHub env variables: "
          echo "MODULE_VERSION = ${{ env.MODULE_VERSION }}"

      - name: "Commit if develop branch"
        if: github.ref == 'refs/heads/develop'
        run: |
          git diff-index --quiet HEAD || git commit -am "Develop: bump to v${{ env.MODULE_VERSION }}"
          git push

      - name: "Commit if main branch"
        if: github.ref == 'refs/heads/main'
        run: |
          git diff-index --quiet HEAD || git commit -am "Bump to v${{ env.MODULE_VERSION }}"
          git push

        # Uploads the build powershell module as an artifact
      - name: Upload Build Artifact
        uses: actions/upload-artifact@v2
        with:
          name: module-artifact # Naming the powershell module artifact
          path: ./{{ env.MODULE_NAME }}/Output/ # Saving the powershell module artifact to the path ./PoshCodex/Output/

  # 2nd Job -- Releasing the module, skip job if should_skip is true
  release:
    needs: [pre_job, build]
    # Only run the "release" job if current branch is main, AND should_skip is NOT 'true'
    # This will break if 'pull_request' is added to the workflow triggers, since PRs don't have a current branch before they are merged.
    if: github.ref == 'refs/heads/main' && needs.pre_job.outputs.should_skip != 'true'
    runs-on: ubuntu-latest
    steps:
      # Check out the main branch
      - uses: actions/checkout@main

        # Downloads the powershell module build artifact made in the build step
      - name: Download build artifact
        uses: actions/download-artifact@v2
        with:
          name: module-artifact # Name of the powershell module artifact
          path: ./Artifact/ # Downloads the module to the path ./Artifact/

        # Publishing the module to powershell gallery
      - name: Publish to Powershell Gallery
        # You may pin to the exact commit or the version.
        # uses: pcgeek86/publish-powershell-module-action@2a7837ce0746ea58c40574d8d6cbc6c44238edb7
        uses: pcgeek86/publish-powershell-module-action@v20
        with:
          modulePath: ./Artifact/${{ env.MODULE_NAME }} # Using the environment variable to find the module name
          NuGetApiKey: ${{ secrets.NUGETAPIKEY }} # Using the NugetAPI key set in GitHub Secrets
